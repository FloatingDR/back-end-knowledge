## 1. 缓存击穿

缓存击穿是指一个请求要访问的数据，**缓存中没有，但数据库中有**。

这种情况一般来说就是缓存过期了，但是这时候由于并发访问这个缓存的请求很多，这又是一个热点key，请求同时过来，在缓存中没有取到数据，所以又同时去访问数据库取数据，引起数据库流量激增，压力瞬间增大。

解决方案：

- **互斥锁方案**，思路就是如果从 redis 中没有获取到数据，就让一个线程去数据库查询数据，然后构建缓存，其他线程就等着，过一段时间再去 redis 中获取。这个方案能解决问题，但是缺点是由于需要阻塞其他线程，影响系统吞吐量
- **后台更新**，后台使用一个定时任务，专门主动更新即将过期的数据。
- **永不过期**，热点 key 设置为永不过期

## 2. 缓存穿透

缓存穿透是指一个请求要访问的数据，**缓存和数据库中都没有**，而请求每次都打到数据库上，给数据库造成了压力，一般来说这样的请求属于恶意请求。

解决方案：

- **缓存空对象**，在数据即使查到的是空对象，也需要把这个空对象缓存起来，下次同样的请求就会命中这个空对象，缓存层就处理了这个请求，不会对数据库产生压力。

  > 但这样有个问题，如果在某个时间，缓存为空的记录，在数据库里面有值了，该怎么办？
  >
  > 解决方案一：设置缓存的时候，同时设置一个过期时间，这样过期之后，就会重新去数据库查询最新的数据并缓存起来
  >
  > 解决方案二：如果对实时性要求非常高的话，那就在写数据库的同时也写入缓存
  >
  > 解决方案三：如果对实时性要求不是很高，那就写数据库的时候给消息队列发送一条数据，让消息队列再通知处理缓存的逻辑去数据库取出最新的数据
  >
  > 这个问题也同时涉及到数据库和缓存一致性的问题

- **布隆过滤器**，布隆过滤器认为某个值存在时，这个值可能存在，也可能不存在；当它说不存在的时候，肯定就是不存在的。缺点是，布隆过滤器不支持删除元素。

  ```java
  // funnel：数据类型(一般是调用Funnels工具类中的)
  // expectedInsertions：期望插入的值的个数
  // fpp 错误率(默认值为0.03)
  BloomFilter<String> bloomFilter = BloomFilter.create(Funnels.stringFunnel(Charsets.UTF_8), 100000, 0.01);
  bloomFilter.put("sjt");
  bloomFilter.put("stt");
  System.out.println(bloomFilter.mightContain("stt"));
  ```

## 3. 缓存雪崩

缓存雪崩是指缓存中大多数的数据在**同一时间到达过期时间，或者缓存服务直接挂了**，这时候，流量打在数据库上，引起数据库流量激增，压力增大。

解决方案：

- **加互斥锁**，缓存雪崩可以看作多个缓存击穿，所以也可以使用互斥锁的解决方案
- **错峰过期**，在设置 key 过期时间的时候，再加上一个短的随机的过期时间，这样就能避免大量缓存在同一时间过期
- **缓存集群**，如果对于缓存服务挂掉的情况，大多数原因是单点应用。那么就可以引入 redis 集群，使用主从加哨兵。
- **限流器+本地缓存**，如果要考虑整个缓存集群都挂掉的情况，可以引入限流器，比如 Hystrix，然后是心啊服务降级。假如限流器设置每秒最多 5千个请求，那么这个时候来了8千个请求，多出来的 3000 个就走降级流程。进来的这 5000 个请求，如果 redis 挂了，也是有可能打满数据的，那么这个时候就可以用本地缓存，类似于 guava cache，帮数据库减轻压力。