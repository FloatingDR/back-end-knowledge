# 1. 生产者概述

kafka发送消息的步骤：

![kafka生产者组件图](/Users/taylor/后端开发知识点总结/Kafka/images/kafka生产者组件图.jpg)

1. ProducerRecord 对象需要包含目标主题和发送的内容，还可以指定键或者分区。在发送 ProducerRecord 对象时，生产者要先把键和值对象序列化成字节数组，这样它们才能在网络上传输。

2. 接下来，数据被传给分区器。如果之前在 ProducerRecord 对象里面指定了分区，那么分区器就不会再做任何事情，直接把指定的分区返回。如果没有指定分区，那么分区器会根据 ProducerRecord 对象的键来选择一个分区。选好分区以后，生产者就知道该往哪个锥体和分区发送这条记录了。紧接着，这条记录被添加到一个记录批次里，这个批次里的所有消息会被发送到相同的主题和分区上。有一个独立的线程负责把这些记录批次发送到相应的 broker 上。
3. 服务器在收到这些消息时会返回一个响应。如果消息成功写入 kafka，就返回一个 RecordMetaData 对象，它包含了主题和分区信息，以及记录在分区里的偏移量。如果写入失败，就会返回一个错误。生产者在收到错误之后会尝试重新发送消息，几次之后如果还是失败，就返回错误信息。

# 2. 创建Kafka生产者

**Kafka生产者有3个必选的属性：bootstrap.servers、key.serializer、value.serializer**

Kafkas生产者发送消息主要有以下3种方式：

1. 发送并忘记（fire-and-forget）：把消息发送给服务器，但并不关心它是否会到达。大多数情况下，消息会正常到达，因为Kafka是高可用的，而且生产者会自动尝试重发。不过这种方式有时候也会丢失一些消息。
2. 同步发送：使用 send() 方法发送消息，它会返回一个 Future 对象，调用 get() 方法进行等待，就可以知道消息是否发送成功。
3. 异步发送：调用 send() 方法发送消息，并指定一个回调函数，服务器在返回响应时调用该函数。

KafkaProducer 一般会发送两类错误。其中一种是可重试错误，这类错误可以通过重发消息来解决。比如对于连接错误，可以通过再次建立连接来解决，“无主（no leader）”错误则可以通过重新为分区选举首领来解决。KafkaProducer 可以被配置成自动重试，如果在多次重试后仍然无法解决问题，应用程序会收到一个重试异常。另一类错误无法通过重试解决，比如“消息太大”异常。对于这类消息，KafkaProducer 不会进行任何重试，直接抛出异常。

# 3. 生产者的配置

以下几个参数在内存使用、性能和可靠性方面对生产者影响比较大。

**1. acks**

acks 参数指定了必须要有多少个分区副本收到消息，生产者才会认为消息写入是成功的。这个参数对消息丢失的可能性有重要影响。该参数有如下选项。

- 如果acks=0，生产者在成功写入消息之前不会等待任何来自服务器的响应。也就是说，如果当中出现了问题，导致服务器没有收到消息，那么生产者就无从得知。消息也就丢失了。不过，因为生产者不需要等待服务器的响应，所以它可以以网络能够支持的最大速度发送消息，从而达到很高的吞吐量。
- 如果acks=1，只要集群的首领节点收到消息，生产者就会收到一个来自服务器的成功响应。如果消息无法到达首领节点（比如首领节点奔溃，新的首领还没有被选举出来），生产者会收到一个错误响应，为了避免数据丢失，生产者会重发消息。不过，如果一个没收到消息的节点成为新首领，消息还是会丢失。这个时候的吞吐量取决于使用的是同步发送还是异步发送。如果让发送客户端等待服务器的响应，显然会增加延迟，如果客户端使用回调，延迟问题会得到缓解，不过吞吐量还是会受发送中消息数量的限制（比如，生产者在收到服务器响应之前可以发送多少个消息）。
- 如果acks=all，只有当所有参与复制的节点全部收到消息时，生产者才会收到一个来自服务器的成功响应。这种模式是最安全的，它可以保证不止一个服务器收到消息，就算有服务器发送奔溃，整个集群仍然可以允许。 不过它的延迟比acks=1时更高。

**2. buffer.memory**

该参数用来设置生产者内存缓冲区的大小，生产者用它缓冲要发送到服务器的消息。如果应用程序发送消息的速度超过发送到服务器的速度，会导致生产者空间不足，这个时候，send() 方法调用要么被阻塞，要么抛出异常，这要取决于如何设置 block.on.buffer.full 参数（在 0.9.0.0 里面被替换成了 max.block.ms，表示在抛出异常之前可以阻塞一段时间）。

**3. coimpression.type**

默认情况下，消息发送时不会压缩。该参数可以设置为 snappy、gzip 或 lz4。使用压缩可以降低网络传输开销和存储开销，而这往往是向 Kafka 发送消息的瓶颈所在。

**4. retries**

生产者从服务器收到的错误有可能是临时性的错误。这种情况下，retries 参数的值决定了生产者可以重发消息的次数，如果达到这个次数，生产者会放弃重试并返回错误。默认情况下，生产者会在每次重试之前等待100ms，不过可以通过retry.backoff.ms 参数来改变这个时间间隔。建议在设置重试次数和重试时间间隔之前，先测试一下恢复一个崩溃节点需要多长时间（比如所有分区选举出首领需要多长时间），让总的重试时间比 Kafka 集群从奔溃中恢复的时间长，否则生产者会过早地放弃重试。

**5. batch.size**

当有多个消息需要被发送到同一个分区时，生产者会把它们放到同一个批次里。该参数指定了一个批次可以使用的内存大小，按照字节数计算（而不是消息个数）。当批次被填满，批次里的所有消息会被发送出去。不过生产者并不一定都会等到批次被填满才发送。

**6. ligner.ms**

该参数指定了生产者在发送批次之前等待更多消息加入批次的时间。KafkaProducer会在批次填满或 linger.ms 达到上限时把批次发送出去。默认情况下，只要有可用的线程，生产者就会把消息发送出去，就算批次里只有一个消息。把 ligner.ms 设置成比 0 大的树，让生产者在发送批次之前等待一会，使更多的消息加入到这个批次。虽然这样会增加延迟，但也会提高吞吐量（因为一次性发送更多的消息，每个消息的开销就变小了）。

**7. client.id**

该参数可以是任意的字符串，服务器会用它来识别消息的来橱，还可以用在日志和配额指标里。

**8. max.in.fight.requests.pre.connection**

该参数指定了生产者在收到服务器响应之前可以发送多少个消息。它的值越高，就会占用越多的内存，不过也会提升吞吐量。把它设为 1 可以保证消息是按照发送的顺序写入服务器的，即使发生了重试。

**9. timeout.ms、request.timeout.ms 和 metadata.fetch.timeout.ms**

request.timeout.ms 指定了生产者在发送数据时等待服务器返回响应的时间，metadata.fetch.timeout.ms 指定了生产者在获取元数据（比如目标分区的首领是谁）时等待服务器返回响应的时间。如果等待响应超时，那么生产者要么重试发送数据，要么返回一个错误（抛出异常或执行回调）。timeout.ms 指定了 broker 等待同步副本返回确认的时间，与 acks 的配置相匹配——如果在指定时间内没有收到同步副本的确认，那么broker就会返回一个错误。

**10. max.block.ms**

该参数指定了在调用 send 方法或使用 partitionsFor 方法获取元数据时的阻塞时间。当生产者的发送缓冲区已满，或者没有可用的元数据时，这些方法就会阻塞。在阻塞时间达到 max.block.ms 时，生产者会抛出超时异常。

**11. max.request.size**

该参数用于控制生产者发送的请求大小。它可以指能发送的单个消息的最大值，也可以指单个请求里所有消息总的大小。例如，假设这个值为 1MB，那么可以发送的单个醉倒消息为 1MB，后者生产者可以在单个请求里发送一个批次，该批次包含了 1000 个消息，每个消息大小为 1KB。另外，broker 对可接收的消息最大值也有自己的限制（message.max.bytes），所以两边的配置最好可以匹配，避免生产者发送的消息被 broker 拒绝。

**12. receive.buffer.bytes 和 send.buffer.bytes**

这两个参数分别指定了 TCP socket 接收和发送数据包的缓冲区大小。如果它们被设为-1，就使用操作系统的默认值。如果生产者或消费者与 broker 处于不同的数据中心，那么可以适当增大这些值，因为跨数据中心的网络一般都有比较高的延迟和比较低的带宽。

# 4. 顺序保证

Kafka 可以保证同 一 个分区里的消息是有序的。也就是说，如果生产者按照

一定的顺序发送消息， broker就会按照这个顺序把它们写入分区，消费者也 会按照同样的顺序i卖取它们。在某些情况下 ， 顺序是非常重要的。例如，往 一个账户存入 100 元再取出来，这个与先取钱再存钱是截然不同的。不过， 有些场景对顺序不是很敏感。

如果把 retries 设为非零整数，同时把 max.in.flight.requests.per.connection 设为比 1 大的数，那么，如果第一个批次消息写入失败，而第二个批次写入 成功， broker会重试写入第一个批次。如果此时第一个批次也写入成功，那 么两个批次的顺序就反过来了。

一般来说，如果某些场景要求消息是有序的，那么消息是否写入成功 也是 很关键的，所以不建议把 retries 设为 0。可以把 max.in.flight.requests.per.connection 设为 1，这样在生产者尝试发送第一批悄息时，就不会有其 他的消息发送给 broker。不过这样会严重影响生产者的吞吐量 ，所以 只有在 对消息的顺序有严格要求的情况下才能这么做。

