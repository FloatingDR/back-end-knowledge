# 隔离性和隔离级别

提到事务，就绕不开 ACID（Atomicity、Consistency、Isolation、Durability 即原子性、一致性、隔离性、持久性）。我们来说说其中的 I，也就是“隔离性”。

> ACID 是怎么保证的？
>
> A：由 undo log 保证，它记录了需要回滚的日志信息，事务回滚时撤销已经执行的 sql
>
> C：由其他三大特性保证、程序代码也要保证业务上的一致性
>
> I：由 MVCC 来保证
>
> D：由内存 + redo log 来保证，mysql 修改数据同时在内存和 redo log 记录这次操作，宕机的时候可以从 redo log 恢复

当数据库上有多个事务同时执行的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题，为了解决这些问题，就有了 “隔离级别” 的概念。

SQL 标准的事务隔离级别包括：读未提交（read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（serialized）。

- 读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到
- 读提交是指，一个事务提交之后，它所做的变更才会被其他事务看到
- 可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的
- 串行化，对于同一行记录，写会加写锁，读会加读锁，当出现读写锁冲突的时候，后访问的事务必须等前面一个事务执行完成，才能继续执行

在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。在可重复读的隔离级别下，这个视图是在事务启动时创建的，整

个事务存在期间都用这个视图。在读提交隔离级别下，这个视图时在每个SQL语句开始执行的时候创建的。这里需要注意的是，读未提交隔离级别下之间返回记录上的最新值，没有视图概念，而串行化隔离级别下直接用加锁的方式来避免并行访问。

